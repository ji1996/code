<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>B2R2.Core</name></assembly>
<members>
<member name="F:B2R2.ErrorCase.InvalidFunctionAddress">
<summary>
 Invalid function address is encountered during a CFG analysis.
</summary>
</member>
<member name="F:B2R2.ErrorCase.InvalidFileFormat">
<summary>
 Invalid file format.
</summary>
</member>
<member name="F:B2R2.ErrorCase.ItemNotFound">
<summary>
 Item does not exist.
</summary>
</member>
<member name="F:B2R2.ErrorCase.SymbolNotFound">
<summary>
 Symbol does not exist.
</summary>
</member>
<member name="F:B2R2.ErrorCase.InvalidExprEvaluation">
<summary>
 Invalid expression is evaluated.
</summary>
</member>
<member name="F:B2R2.ErrorCase.InvalidMemoryRead">
<summary>
 Invalid access to memory.
</summary>
</member>
<member name="F:B2R2.ErrorCase.ParsingFailure">
<summary>
 Failed to parse instruction(s).
</summary>
</member>
<member name="T:B2R2.ErrorCase">
<summary>
 Error cases and corresponding numbers for B2R2.
</summary>
</member>
<member name="T:B2R2.OutString">
<summary>
 OutString represents an output string generated from rear-end applications.
</summary>
</member>
<member name="T:B2R2.ConsoleNullPrinter">
<summary>
 ConsoleCachedPrinter does not print anything. This is the same as
 redirecting outputs to /dev/null.
</summary>
</member>
<member name="T:B2R2.ConsoleCachedPrinter">
<summary>
 ConsoleCachedPrinter prints out non-colored strings only when the Flush
 method is called. All the colored strings will be normalized to plain
 strings. It will simply stack up all the output candidates before Flush is
 called. This is useful for performance-critical applications.
</summary>
</member>
<member name="T:B2R2.ConsolePrinter">
<summary>
 ConsolePrinter simply prints out strings to console whenever a print method
 is called. This printer does not perform any caching, so it immediately
 flushes out all the strings to console.
</summary>
</member>
<member name="M:B2R2.Printer.PrintTwoColsWithColorOnSnd(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{B2R2.Color,System.String}})">
<summary>
 Print out a line with two columns. Each column has a predefined width, and
 the second column will be colored.
</summary>
</member>
<member name="M:B2R2.Printer.PrintTwoCols(System.String,System.String)">
<summary>
 Print out a line with two columns. Each column has a predefined width.
</summary>
</member>
<member name="M:B2R2.Printer.PrintSubsubsectionTitle(System.String)">
<summary>
 Print out the subsubsection title.
</summary>
</member>
<member name="M:B2R2.Printer.PrintSubsectionTitle(System.String)">
<summary>
 Print out the subsection title.
</summary>
</member>
<member name="M:B2R2.Printer.PrintSectionTitle(System.String)">
<summary>
 Print out the section title.
</summary>
</member>
<member name="M:B2R2.Printer.PrintRow(System.Boolean,Microsoft.FSharp.Collections.FSharpList{B2R2.TableColumn},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Print out table row for the given string list.
</summary>
</member>
<member name="M:B2R2.Printer.PrintRow(System.Boolean,Microsoft.FSharp.Collections.FSharpList{B2R2.TableColumn},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Tuple{B2R2.Color,System.String}}})">
<summary>
 Print out table row for the given ColoredString list.
</summary>
</member>
<member name="M:B2R2.Printer.PrintLineIfPrevLineWasNotEmpty">
<summary>
 Print out a newline only if the previous output was not empty (i.e., a
 line with only a newline). In other words, this function will not output
 anything if the previous output was an empty line. This is to make sure we
 output only one single empty line in some situations.
</summary>
</member>
<member name="M:B2R2.Printer.PrintLine">
<summary>
 Print out a newline.
</summary>
</member>
<member name="M:B2R2.Printer.PrintLine(System.String,System.Object[])">
<summary>
 Print out the formated string with newline.
</summary>
</member>
<member name="M:B2R2.Printer.PrintLine(System.String)">
<summary>
 Print out the formated string with newline.
</summary>
</member>
<member name="M:B2R2.Printer.PrintLine(Microsoft.FSharp.Collections.FSharpList{System.Tuple{B2R2.Color,System.String}})">
<summary>
 Print out the given ColoredString with newline.
</summary>
</member>
<member name="M:B2R2.Printer.PrintLine(B2R2.OutString)">
<summary>
 Print out the given OutString with newline.
</summary>
</member>
<member name="M:B2R2.Printer.Print(System.String,System.Object[])">
<summary>
 Print out the formated string.
</summary>
</member>
<member name="M:B2R2.Printer.Print(Microsoft.FSharp.Collections.FSharpList{System.Tuple{B2R2.Color,System.String}})">
<summary>
 Print out the given ColoredString.
</summary>
</member>
<member name="M:B2R2.Printer.Print(B2R2.OutString)">
<summary>
 Print out the given OutString.
</summary>
</member>
<member name="M:B2R2.Printer.Flush">
<summary>
 Flush out everything.
</summary>
</member>
<member name="T:B2R2.Printer">
<summary>
 Any B2R2&apos;s layers should *not* use System.Console or `printfn` to directly
 output strings. Instead, they should resort to the Printer to &quot;indirectly&quot;
 print out strings.
</summary>
</member>
<member name="T:B2R2.TableConfig">
<summary>
 Define a output configuration of a table.
</summary>
</member>
<member name="T:B2R2.TableColumn">
<summary>
 Define a column of a table with a specified width in bytes (# of chars).
</summary>
</member>
<member name="T:B2R2.RegType">
<summary>
 Types that a register can have. This essentially means how many bits are in
 the register.
</summary>
</member>
<member name="T:B2R2.rt">
<summary>
 A unit for RegType.
</summary>
</member>
<member name="T:B2R2.RegisterID">
<summary>
 RegisterID is a platform-independent representation of a register.
</summary>
</member>
<member name="T:B2R2.NonEmptyRegisterSet">
<summary>
 Non-empty register set.
</summary>
</member>
<member name="T:B2R2.EmptyRegisterSet">
<summary>
 Empty register set.
</summary>
</member>
<member name="P:B2R2.RegisterSet.Tag">
<summary>
 Tag identifies ISA.
</summary>
</member>
<member name="P:B2R2.RegisterSet.BitArray">
<summary>
 An internal array storing the register set.
</summary>
</member>
<member name="P:B2R2.RegisterSet.AuxSet">
<summary>
 A backup storage for unknown variables, which does not have a RegisterID.
 For example, when writing a symbolic executor, we may encounter unknown
 variables, i.e., fresh symbolic variables. We store them in this set.
</summary>
</member>
<member name="P:B2R2.RegisterSet.ArrSize">
<summary>
 Size of the internal array.
</summary>
</member>
<member name="M:B2R2.RegisterSet.Union(B2R2.RegisterSet)">
<summary>
 Union of two register sets.
</summary>
</member>
<member name="M:B2R2.RegisterSet.ToSet">
<summary>
 Return the set of register indices.
</summary>
</member>
<member name="M:B2R2.RegisterSet.Remove(System.Int32)">
<summary>
 Remove a register from the set.
</summary>
</member>
<member name="M:B2R2.RegisterSet.RegIDToIndex(System.Int32)">
<summary>
 Obtain a unique index to the internal array from a given RegisterID.
</summary>
</member>
<member name="M:B2R2.RegisterSet.New(System.UInt64[],Microsoft.FSharp.Collections.FSharpSet{System.Int32})">
<summary>
 Create a new RegisterSet from a given array and a set. This method should
 be overridden by ISA-specific RegisterSet implementation.
</summary>
</member>
<member name="M:B2R2.RegisterSet.MakeInternalBitArray``1(System.Int32)">
<summary>
 Create an internal bit array of size.
</summary>
</member>
<member name="M:B2R2.RegisterSet.IsEmpty">
<summary>
 Check if the set is empty.
</summary>
</member>
<member name="M:B2R2.RegisterSet.IsBitSet(System.Int32,System.UInt64)">
<summary>
 Check if the nth bit is set on the value v.
</summary>
</member>
<member name="M:B2R2.RegisterSet.Intersect(B2R2.RegisterSet)">
<summary>
 Intersection of two register sets.
</summary>
</member>
<member name="M:B2R2.RegisterSet.IndexToRegID(System.Int32)">
<summary>
 Obtain a RegisterID from a given index.
</summary>
</member>
<member name="M:B2R2.RegisterSet.GetIndex(System.Int32,System.Int32)">
<summary>
 Get the register index from the given bucket id and the offset.
</summary>
</member>
<member name="M:B2R2.RegisterSet.GetBucketAndOffset(System.Int32)">
<summary>
 Get the bucket and the offset from the given index.
</summary>
</member>
<member name="M:B2R2.RegisterSet.Exists(System.Int32)">
<summary>
 Check if a register exists in the set.
</summary>
</member>
<member name="M:B2R2.RegisterSet.Add(System.Int32)">
<summary>
 Add a register to the set.
</summary>
</member>
<member name="T:B2R2.RegisterSet">
<summary>
 RegisterSet is an efficient set data structure using arrays for managing a
 set of registers.
</summary>
</member>
<member name="T:B2R2.RegisterSetTag">
<summary>
 A tag used in RegisterSet for identifying distinct set of registers for
 different ISAs.
</summary>
</member>
<member name="T:B2R2.WordSize">
<summary>
 B2R2 represents the word size of a CPU with WordSize, which can be either
 32- or 64-bit.
</summary>
</member>
<member name="F:B2R2.Endian.Big">
<summary>
 Big endian
</summary>
</member>
<member name="F:B2R2.Endian.Little">
<summary>
 Little endian
</summary>
</member>
<member name="T:B2R2.Endian">
<summary>
 Endianness.
</summary>
</member>
<member name="F:B2R2.OS.MacOSX">
<summary>
 MacOSX.
</summary>
</member>
<member name="F:B2R2.OS.Linux">
<summary>
 Linux.
</summary>
</member>
<member name="F:B2R2.OS.Windows">
<summary>
 windows.
</summary>
</member>
<member name="T:B2R2.OS">
<summary>
 Specify OS type.
</summary>
</member>
<member name="T:B2R2.ISA">
<summary>
 Instruction Set Architecture (ISA).
</summary>
</member>
<member name="F:B2R2.ArchOperationMode.NoMode">
<summary>
 No mode. This is used for architectures that do not have any operation
 mode.
</summary>
</member>
<member name="F:B2R2.ArchOperationMode.ThumbMode">
<summary>
 Thumb mode.
</summary>
</member>
<member name="F:B2R2.ArchOperationMode.ARMMode">
<summary>
 ARM mode.
</summary>
</member>
<member name="T:B2R2.ArchOperationMode">
<summary>
 Some ISA, such as ARM, have their own operation mode, which can vary at
 runtime. For example, ARM architecture can switch between Thumb and ARM
 mode. ArchOperationMode decides which mode to consider at the time of
 parsing/lifting machine instructions.
</summary>
</member>
<member name="F:B2R2.Architecture.UnknownISA">
<summary>
 Unknown ISA.
</summary>
</member>
<member name="F:B2R2.Architecture.CILIntel64">
<summary>
 CIL + x64 (PE32+)
</summary>
</member>
<member name="F:B2R2.Architecture.CILIntel32">
<summary>
 CIL + x86 (PE32).
</summary>
</member>
<member name="F:B2R2.Architecture.CILOnly">
<summary>
 Common Intermediate Language (CIL), aka MSIL.
</summary>
</member>
<member name="F:B2R2.Architecture.TMS320C6000">
<summary>
 TMS320C64x, TMS320C67x, etc.
</summary>
</member>
<member name="F:B2R2.Architecture.TMS320C5000">
<summary>
 TMS320C54x, TMS320C55x, etc.
</summary>
</member>
<member name="F:B2R2.Architecture.EVM">
<summary>
 Ethereum Vritual Machine.
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS64R6">
<summary>
 MIPS64R6 (64-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS64R2">
<summary>
 MIPS64R2 (64-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS64">
<summary>
 MIPS64 (64-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS32R6">
<summary>
 MIPS32 Release6 (32-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS32R2">
<summary>
 MIPS32 Release2 (32-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS32">
<summary>
 MIPS32 (32-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS5">
<summary>
 MIPS5 (64-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS4">
<summary>
 MIPS4 (64-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS3">
<summary>
 MIPS3 (64-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS2">
<summary>
 MIPS2 (32-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.MIPS1">
<summary>
 MIPS1 (32-bit mode).
</summary>
</member>
<member name="F:B2R2.Architecture.AARCH64">
<summary>
 ARMv8 64-bit mode.
</summary>
</member>
<member name="F:B2R2.Architecture.AARCH32">
<summary>
 ARMv8 32-bit mode.
</summary>
</member>
<member name="F:B2R2.Architecture.ARMv7">
<summary>
 ARMv7.
</summary>
</member>
<member name="F:B2R2.Architecture.IntelX64">
<summary>
 x86-64 (amd64).
</summary>
</member>
<member name="F:B2R2.Architecture.IntelX86">
<summary>
 x86 (i386).
</summary>
</member>
<member name="T:B2R2.Architecture">
<summary>
 Architecture types.
</summary>
</member>
<member name="F:B2R2.FileFormat.WasmBinary">
<summary>
 Wasm binary.
</summary>
</member>
<member name="F:B2R2.FileFormat.MachBinary">
<summary>
 Mach-O binary.
</summary>
</member>
<member name="F:B2R2.FileFormat.PEBinary">
<summary>
 PE binary.
</summary>
</member>
<member name="F:B2R2.FileFormat.ELFBinary">
<summary>
 ELF binary.
</summary>
</member>
<member name="F:B2R2.FileFormat.RawBinary">
<summary>
 Raw binary without any specific file format: a sequence of bytes.
</summary>
</member>
<member name="T:B2R2.FileFormat">
<summary>
 Types of binary file format.
</summary>
</member>
<member name="T:B2R2.LinuxSyscall">
<summary>
 Linux syscall type.
</summary>
</member>
<member name="T:B2R2.Addr">
<summary>
 Addresses are represented with a 64-bit integer in B2R2.
</summary>
</member>
<member name="F:B2R2.AddrRange.Max">
<summary>
 Maximum value (upper bound) of the interval.
</summary>
</member>
<member name="F:B2R2.AddrRange.Min">
<summary>
 Minimum value (lower bound) of the interval.
</summary>
</member>
<member name="M:B2R2.AddrRange.ToTuple">
 <summary>
 Get the corresponding tuple (Addr, Addr) from the AddrRange.
 </summary>
 <returns>
 A tuple of min (inclusive) and max (exclusive).
 </returns>
</member>
<member name="M:B2R2.AddrRange.GetMin(B2R2.AddrRange)">
 <summary>
 Get the min value (inclusive) of the AddrRange.
 </summary>
 <returns>
 The min value.
 </returns>
</member>
<member name="M:B2R2.AddrRange.GetMax(B2R2.AddrRange)">
 <summary>
 Get the max value (exclusive) of the AddrRange.
 </summary>
 <returns>
 The max value.
 </returns>
</member>
<member name="M:B2R2.AddrRange.#ctor(System.UInt64,System.UInt64)">
 <summary>
 Initialize an instance of AddrRange from a given interval.
 </summary>
 <param name="min">The start address.</param>
 <param name="max">The end address + 1.</param>
 <returns>
 An instance of AddrRange.
 </returns>
</member>
<member name="T:B2R2.AddrRange">
<summary>
 AddrRange is a tuple (min, max) that represents a range of address values
 that are greater or equal to the min value (inclusive) and are less than the
 max value (exclusive). To access the min and the max value of a range, use
 either getMin or getMax function.
</summary>
</member>
<member name="T:B2R2.ARMap`1">
<summary>
 This is a non-overlapping interval map that we call &quot;Address Range Map&quot;
 (ARMap). This map internally forms a red-black tree, which follows the
 implementation of the paper written by Kimball Germane and Matthew Might:
 &quot;Deletion: The Curse of the Red-Black Tree&quot;, Journal of Functional
 Programming, vol. 24, no. 4, 2014.
</summary>
</member>
<member name="T:B2R2.BitVectorBig">
<summary>
 This is a BitVector with its length less than or equal to 64&lt;rt&gt;. This is
 preferred because all the operations will be much faster than BitVectorBig.
</summary>
</member>
<member name="T:B2R2.BitVectorSmall">
<summary>
 This is a BitVector with its length less than or equal to 64&lt;rt&gt;. This is
 preferred because all the operations will be much faster than BitVectorBig.
</summary>
</member>
<member name="M:B2R2.BitVector.ZExt(B2R2.BitVector,System.Int32)">
<summary>
 BitVector zero-extension.
</summary>
</member>
<member name="M:B2R2.BitVector.Zero(System.Int32)">
<summary>
 Return zero (0) of the given bit length.
</summary>
</member>
<member name="M:B2R2.BitVector.ValToString(B2R2.BitVector)">
<summary>
 Get the string representation of a BitVector without appended type info.
</summary>
</member>
<member name="M:B2R2.BitVector.UnsignedMin(System.Int32)">
<summary>
 BitVector representing a unsigned minimum integer for the given RegType.
</summary>
</member>
<member name="M:B2R2.BitVector.UnsignedMax(System.Int32)">
<summary>
 BitVector representing a unsigned maximum integer for the given RegType.
</summary>
</member>
<member name="M:B2R2.BitVector.ToUInt64(B2R2.BitVector)">
<summary>
 Get a uint64 value from a BitVector.
</summary>
</member>
<member name="M:B2R2.BitVector.ToUInt32(B2R2.BitVector)">
<summary>
 Get a uint32 value from a BitVector.
</summary>
</member>
<member name="M:B2R2.BitVector.ToString(B2R2.BitVector)">
<summary>
 Get the string representation of a BitVector.
</summary>
</member>
<member name="M:B2R2.BitVector.ToInt64(B2R2.BitVector)">
<summary>
 Get an int64 value from a BitVector.
</summary>
</member>
<member name="M:B2R2.BitVector.ToInt32(B2R2.BitVector)">
<summary>
 Get an int32 value from a BitVector.
</summary>
</member>
<member name="M:B2R2.BitVector.Sub(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector subtraction.
</summary>
</member>
<member name="M:B2R2.BitVector.SMod(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector signed modulo.
</summary>
</member>
<member name="M:B2R2.BitVector.SMin(B2R2.BitVector,B2R2.BitVector)">
<summary>
 Return a smaller BitVector (with signed comparison).
</summary>
</member>
<member name="M:B2R2.BitVector.SMax(B2R2.BitVector,B2R2.BitVector)">
<summary>
 Return a larger BitVector (with signed comparison).
</summary>
</member>
<member name="M:B2R2.BitVector.SLt(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector signed less than.
</summary>
</member>
<member name="M:B2R2.BitVector.SLe(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector signed less than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.SignedMin(System.Int32)">
<summary>
 BitVector representing a signed minimum integer for the given RegType.
</summary>
</member>
<member name="M:B2R2.BitVector.SignedMax(System.Int32)">
<summary>
 BitVector representing a signed maximum integer for the given RegType.
</summary>
</member>
<member name="M:B2R2.BitVector.Shr(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector logical shift-right.
</summary>
</member>
<member name="M:B2R2.BitVector.Shl(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector logical shift-left.
</summary>
</member>
<member name="M:B2R2.BitVector.SGt(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector signed greater than.
</summary>
</member>
<member name="M:B2R2.BitVector.SGe(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector signed greater than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.SExt(B2R2.BitVector,System.Int32)">
<summary>
 BitVector sign-extension.
</summary>
</member>
<member name="M:B2R2.BitVector.SDiv(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector signed division.
</summary>
</member>
<member name="M:B2R2.BitVector.Sar(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector arithmetic shift-right.
</summary>
</member>
<member name="M:B2R2.BitVector.op_UnaryNegation(B2R2.BitVector)">
<summary>
 BitVector negation.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Subtraction(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector subtraction.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Subtraction(B2R2.BitVector,System.UInt64)">
<summary>
 BitVector subtraction.
</summary>
</member>
<member name="M:B2R2.BitVector.op_QmarkPercent(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector signed modulo.
</summary>
</member>
<member name="M:B2R2.BitVector.op_QmarkDivide(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector signed division.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Multiply(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector multiplication.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Multiply(B2R2.BitVector,System.UInt64)">
<summary>
 BitVector multiplication.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Modulus(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector unsigned modulo.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Modulus(B2R2.BitVector,System.UInt64)">
<summary>
 BitVector modulo.
</summary>
</member>
<member name="M:B2R2.BitVector.op_LogicalNot(B2R2.BitVector)">
<summary>
 BitVector bitwise not.
</summary>
</member>
<member name="M:B2R2.BitVector.op_ExclusiveOr(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector bitwise XOR.
</summary>
</member>
<member name="M:B2R2.BitVector.op_ExclusiveOr(B2R2.BitVector,System.UInt64)">
<summary>
 BitVector bitwise XOR.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Division(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector unsigned division.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Division(B2R2.BitVector,System.UInt64)">
<summary>
 BitVector division.
</summary>
</member>
<member name="M:B2R2.BitVector.op_BitwiseOr(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector bitwise OR.
</summary>
</member>
<member name="M:B2R2.BitVector.op_BitwiseOr(B2R2.BitVector,System.UInt64)">
<summary>
 BitVector bitwise OR.
</summary>
</member>
<member name="M:B2R2.BitVector.op_BitwiseAnd(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector bitwise AND.
</summary>
</member>
<member name="M:B2R2.BitVector.op_BitwiseAnd(B2R2.BitVector,System.UInt64)">
<summary>
 BitVector bitwise AND.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Addition(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector addition.
</summary>
</member>
<member name="M:B2R2.BitVector.op_Addition(B2R2.BitVector,System.UInt64)">
<summary>
 BitVector addition.
</summary>
</member>
<member name="M:B2R2.BitVector.One(System.Int32)">
<summary>
 Return one (1) of the given bit length.
</summary>
</member>
<member name="M:B2R2.BitVector.OfUInt64(System.UInt64,System.Int32)">
<summary>
 Get a BitVector from an unsigned integer.
</summary>
</member>
<member name="M:B2R2.BitVector.OfUInt32(System.UInt32,System.Int32)">
<summary>
 Get a BitVector from an unsigned integer.
</summary>
</member>
<member name="M:B2R2.BitVector.OfInt64(System.Int64,System.Int32)">
<summary>
 Get a BitVector from a signed integer.
</summary>
</member>
<member name="M:B2R2.BitVector.OfInt32(System.Int32,System.Int32)">
<summary>
 Get a BitVector from a signed integer.
</summary>
</member>
<member name="M:B2R2.BitVector.OfBInt(System.Numerics.BigInteger,System.Int32)">
<summary>
 Get a BitVector from a bigint. We assume that the given RegType (typ) is
 big enough to hold the given bigint. Otherwise, the resulting BitVector
 may contain an unexpected value.
</summary>
</member>
<member name="M:B2R2.BitVector.OfArr(System.Byte[])">
<summary>
 Get a BitVector from a byte array (in little endian).
</summary>
</member>
<member name="M:B2R2.BitVector.Neq(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector not equal.
</summary>
</member>
<member name="M:B2R2.BitVector.Neg(B2R2.BitVector)">
<summary>
 BitVector negation.
</summary>
</member>
<member name="M:B2R2.BitVector.Mul(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector multiplication.
</summary>
</member>
<member name="M:B2R2.BitVector.Mod(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector unsigned modulo.
</summary>
</member>
<member name="M:B2R2.BitVector.Min(B2R2.BitVector,B2R2.BitVector)">
<summary>
 Return a smaller BitVector.
</summary>
</member>
<member name="M:B2R2.BitVector.Max(B2R2.BitVector,B2R2.BitVector)">
<summary>
 Return a larger BitVector.
</summary>
</member>
<member name="M:B2R2.BitVector.Lt(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector less than.
</summary>
</member>
<member name="M:B2R2.BitVector.Le(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector less than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.Itof(B2R2.BitVector,System.Int32)">
<summary>
 BitVector integer to float conversion.
</summary>
</member>
<member name="M:B2R2.BitVector.IsZero(B2R2.BitVector)">
<summary>
 Check if the given BitVector is zero.
</summary>
</member>
<member name="M:B2R2.BitVector.IsUnsignedMax(B2R2.BitVector)">
<summary>
 Does the bitvector represent an unsigned max value?
</summary>
</member>
<member name="M:B2R2.BitVector.IsTrue(B2R2.BitVector)">
<summary>
 Check if the given BitVector is &quot;true&quot;.
</summary>
</member>
<member name="M:B2R2.BitVector.IsSignedMin(B2R2.BitVector)">
<summary>
 Does the bitvector represent a signed min value?
</summary>
</member>
<member name="M:B2R2.BitVector.IsSignedMax(B2R2.BitVector)">
<summary>
 Does the bitvector represent a signed max value?
</summary>
</member>
<member name="M:B2R2.BitVector.IsPositive(B2R2.BitVector)">
<summary>
 Is the bitvector positive?
</summary>
</member>
<member name="M:B2R2.BitVector.IsOne(B2R2.BitVector)">
<summary>
 Check if the given BitVector is one.
</summary>
</member>
<member name="M:B2R2.BitVector.IsNum(B2R2.BitVector,System.UInt64)">
<summary>
 Check if the given BitVector represents the specified number.
</summary>
</member>
<member name="M:B2R2.BitVector.IsNegative(B2R2.BitVector)">
<summary>
 Is the bitvector negative?
</summary>
</member>
<member name="M:B2R2.BitVector.IsFalse(B2R2.BitVector)">
<summary>
 Check if the given BitVector is &quot;false&quot;.
</summary>
</member>
<member name="M:B2R2.BitVector.Gt(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector greater than.
</summary>
</member>
<member name="P:B2R2.BitVector.maxUInt8">
<summary>
 Bitvector of unsigned 8-bit maxvalue.
</summary>
</member>
<member name="P:B2R2.BitVector.maxUInt64">
<summary>
 Bitvector of unsigned 64-bit maxvalue.
</summary>
</member>
<member name="P:B2R2.BitVector.maxUInt32">
<summary>
 Bitvector of unsigned 32-bit maxvalue.
</summary>
</member>
<member name="P:B2R2.BitVector.maxUInt16">
<summary>
 Bitvector of unsigned 16-bit maxvalue.
</summary>
</member>
<member name="P:B2R2.BitVector.T">
<summary>
 True value.
</summary>
</member>
<member name="P:B2R2.BitVector.Length">
<summary>
 BitVector length.
</summary>
</member>
<member name="P:B2R2.BitVector.F">
<summary>
 False value.
</summary>
</member>
<member name="M:B2R2.BitVector.GetValue(B2R2.BitVector)">
<summary>
 Get a numeric value (bigint) from a BitVector.
</summary>
</member>
<member name="M:B2R2.BitVector.GetType(B2R2.BitVector)">
<summary>
 Get the type (length of the BitVector).
</summary>
</member>
<member name="M:B2R2.BitVector.Ge(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector greater than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.FToITrunc(B2R2.BitVector,System.Int32)">
<summary>
 BitVector float to integer conversion with truncation.
</summary>
</member>
<member name="M:B2R2.BitVector.FToIRound(B2R2.BitVector,System.Int32)">
<summary>
 BitVector float to integer conversion with round.
</summary>
</member>
<member name="M:B2R2.BitVector.FToIFloor(B2R2.BitVector,System.Int32)">
<summary>
 BitVector float to integer conversion with flooring.
</summary>
</member>
<member name="M:B2R2.BitVector.FToICeil(B2R2.BitVector,System.Int32)">
<summary>
 BitVector float to integer conversion with ceiling.
</summary>
</member>
<member name="M:B2R2.BitVector.FTan(B2R2.BitVector)">
<summary>
 BitVector tangent.
</summary>
</member>
<member name="M:B2R2.BitVector.FSub(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point subtraction.
</summary>
</member>
<member name="M:B2R2.BitVector.FSqrt(B2R2.BitVector)">
<summary>
 BitVector square root.
</summary>
</member>
<member name="M:B2R2.BitVector.FSin(B2R2.BitVector)">
<summary>
 BitVector sine.
</summary>
</member>
<member name="M:B2R2.BitVector.FPow(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point power.
</summary>
</member>
<member name="M:B2R2.BitVector.FMul(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point multiplication.
</summary>
</member>
<member name="M:B2R2.BitVector.FLt(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point less than.
</summary>
</member>
<member name="M:B2R2.BitVector.FLog(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point logarithm.
</summary>
</member>
<member name="M:B2R2.BitVector.FLe(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point less than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.FGt(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point greater than.
</summary>
</member>
<member name="M:B2R2.BitVector.FGe(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point greater than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.FDiv(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point division.
</summary>
</member>
<member name="M:B2R2.BitVector.FCos(B2R2.BitVector)">
<summary>
 BitVector cosine.
</summary>
</member>
<member name="M:B2R2.BitVector.FCast(B2R2.BitVector,System.Int32)">
<summary>
 BitVector floating point casting.
</summary>
</member>
<member name="M:B2R2.BitVector.FATan(B2R2.BitVector)">
<summary>
 BitVector arc tangent.
</summary>
</member>
<member name="M:B2R2.BitVector.FAdd(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector floating point addition.
</summary>
</member>
<member name="M:B2R2.BitVector.Extract(B2R2.BitVector,System.Int32,System.Int32)">
<summary>
 BitVector extraction.
</summary>
</member>
<member name="M:B2R2.BitVector.Eq(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector equal.
</summary>
</member>
<member name="M:B2R2.BitVector.Div(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector unsigned division.
</summary>
</member>
<member name="M:B2R2.BitVector.Concat(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector concatenation.
</summary>
</member>
<member name="M:B2R2.BitVector.Cast(B2R2.BitVector,System.Int32)">
<summary>
 BitVector type cast.
</summary>
</member>
<member name="M:B2R2.BitVector.Xor(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector bitwise XOR.
</summary>
</member>
<member name="M:B2R2.BitVector.Or(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector bitwise OR.
</summary>
</member>
<member name="M:B2R2.BitVector.Not(B2R2.BitVector)">
<summary>
 BitVector bitwise NOT.
</summary>
</member>
<member name="M:B2R2.BitVector.And(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector bitwise AND.
</summary>
</member>
<member name="M:B2R2.BitVector.Add(B2R2.BitVector,B2R2.BitVector)">
<summary>
 BitVector addition.
</summary>
</member>
<member name="M:B2R2.BitVector.Abs(B2R2.BitVector)">
<summary>
 BitVector absolute value.
</summary>
</member>
<member name="M:B2R2.BitVector.ZExt(System.Int32)">
<summary>
 BitVector zero-extension.
</summary>
</member>
<member name="M:B2R2.BitVector.Xor(B2R2.BitVector)">
<summary>
 BitVector bitwise XOR.
</summary>
</member>
<member name="M:B2R2.BitVector.Xor(System.UInt64)">
<summary>
 BitVector bitwise XOR with uint64.
</summary>
</member>
<member name="M:B2R2.BitVector.ValToString">
<summary>
 Return the string representation of the BitVector value. Type is not
 appended to the output string.
</summary>
</member>
<member name="M:B2R2.BitVector.Sub(B2R2.BitVector)">
<summary>
 BitVector subtraction.
</summary>
</member>
<member name="M:B2R2.BitVector.Sub(System.UInt64)">
<summary>
 BitVector subtraction with uint64.
</summary>
</member>
<member name="M:B2R2.BitVector.SmallValue">
<summary>
 Return the uint64 representation of the bitvector value.
</summary>
</member>
<member name="M:B2R2.BitVector.Shr(B2R2.BitVector)">
<summary>
 BitVector logical shift-right.
</summary>
</member>
<member name="M:B2R2.BitVector.Shl(B2R2.BitVector)">
<summary>
 BitVector logical shift-left.
</summary>
</member>
<member name="M:B2R2.BitVector.Sar(B2R2.BitVector)">
<summary>
 BitVector arithmetic shift-right.
</summary>
</member>
<member name="M:B2R2.BitVector.SMod(B2R2.BitVector)">
<summary>
 BitVector signed modulo.
</summary>
</member>
<member name="M:B2R2.BitVector.SLt(B2R2.BitVector)">
<summary>
 BitVector signed less than.
</summary>
</member>
<member name="M:B2R2.BitVector.SLe(B2R2.BitVector)">
<summary>
 BitVector signed less than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.SGt(B2R2.BitVector)">
<summary>
 BitVector signed greater than.
</summary>
</member>
<member name="M:B2R2.BitVector.SGe(B2R2.BitVector)">
<summary>
 BitVector signed greater than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.SExt(System.Int32)">
<summary>
 BitVector sign-extension.
</summary>
</member>
<member name="M:B2R2.BitVector.SDiv(B2R2.BitVector)">
<summary>
 BitVector signed division.
</summary>
</member>
<member name="M:B2R2.BitVector.Or(B2R2.BitVector)">
<summary>
 BitVector bitwise OR.
</summary>
</member>
<member name="M:B2R2.BitVector.Or(System.UInt64)">
<summary>
 BitVector bitwise OR with uint64.
</summary>
</member>
<member name="M:B2R2.BitVector.Not">
<summary>
 BitVector bitwise NOT.
</summary>
</member>
<member name="M:B2R2.BitVector.Neq(B2R2.BitVector)">
<summary>
 BitVector not equal.
</summary>
</member>
<member name="M:B2R2.BitVector.Neg">
<summary>
 BitVector unary negation.
</summary>
</member>
<member name="M:B2R2.BitVector.Mul(B2R2.BitVector)">
<summary>
 BitVector multiplication.
</summary>
</member>
<member name="M:B2R2.BitVector.Mul(System.UInt64)">
<summary>
 BitVector multiplication with uint64.
</summary>
</member>
<member name="M:B2R2.BitVector.Mod(B2R2.BitVector)">
<summary>
 BitVector unsigned modulo.
</summary>
</member>
<member name="M:B2R2.BitVector.Mod(System.UInt64)">
<summary>
 BitVector unsigned modulo with uint64.
</summary>
</member>
<member name="M:B2R2.BitVector.Lt(B2R2.BitVector)">
<summary>
 BitVector unsigned less than.
</summary>
</member>
<member name="M:B2R2.BitVector.Le(B2R2.BitVector)">
<summary>
 BitVector unsigned less than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.Itof(System.Int32)">
<summary>
 Integer to float conversion.
</summary>
</member>
<member name="M:B2R2.BitVector.IsZero">
<summary>
 Return true if the value is zero.
</summary>
</member>
<member name="M:B2R2.BitVector.IsPositive">
<summary>
 Is this bitvector representing a positive number?
</summary>
</member>
<member name="M:B2R2.BitVector.IsOne">
<summary>
 Return true if the value is one.
</summary>
</member>
<member name="M:B2R2.BitVector.IsNegative">
<summary>
 Is this bitvector representing a negative number?
</summary>
</member>
<member name="M:B2R2.BitVector.Gt(B2R2.BitVector)">
<summary>
 BitVector unsigned greater than.
</summary>
</member>
<member name="M:B2R2.BitVector.Ge(B2R2.BitVector)">
<summary>
 BitVector unsigned greater than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.FtoiTrunc(System.Int32)">
<summary>
 Floating point to integer conversion with truncation.
</summary>
</member>
<member name="M:B2R2.BitVector.FtoiRound(System.Int32)">
<summary>
 Floating point to integer conversion with rounding.
</summary>
</member>
<member name="M:B2R2.BitVector.FtoiFloor(System.Int32)">
<summary>
 Floating point to integer conversion with flooring.
</summary>
</member>
<member name="M:B2R2.BitVector.FtoiCeil(System.Int32)">
<summary>
 Floating point to integer conversion with ceiling.
</summary>
</member>
<member name="M:B2R2.BitVector.FTan">
<summary>
 Floating point tangent.
</summary>
</member>
<member name="M:B2R2.BitVector.FSub(B2R2.BitVector)">
<summary>
 Floating point subtraction.
</summary>
</member>
<member name="M:B2R2.BitVector.FSqrt">
<summary>
 Floating point square root.
</summary>
</member>
<member name="M:B2R2.BitVector.FSin">
<summary>
 Floating point sine.
</summary>
</member>
<member name="M:B2R2.BitVector.FPow(B2R2.BitVector)">
<summary>
 Floating point power.
</summary>
</member>
<member name="M:B2R2.BitVector.FMul(B2R2.BitVector)">
<summary>
 Floating point multiplication.
</summary>
</member>
<member name="M:B2R2.BitVector.FLt(B2R2.BitVector)">
<summary>
 Floating point less than.
</summary>
</member>
<member name="M:B2R2.BitVector.FLog(B2R2.BitVector)">
<summary>
 Floating point logarithm.
</summary>
</member>
<member name="M:B2R2.BitVector.FLe(B2R2.BitVector)">
<summary>
 Floating point less than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.FGt(B2R2.BitVector)">
<summary>
 Floating point greater than.
</summary>
</member>
<member name="M:B2R2.BitVector.FGe(B2R2.BitVector)">
<summary>
 Floating point greater than or equal.
</summary>
</member>
<member name="M:B2R2.BitVector.FDiv(B2R2.BitVector)">
<summary>
 Floating point division.
</summary>
</member>
<member name="M:B2R2.BitVector.FCos">
<summary>
 Floating point cosine.
</summary>
</member>
<member name="M:B2R2.BitVector.FCast(System.Int32)">
<summary>
 Floating point casting.
</summary>
</member>
<member name="M:B2R2.BitVector.FAdd(B2R2.BitVector)">
<summary>
 Floating point addition.
</summary>
</member>
<member name="M:B2R2.BitVector.FATan">
<summary>
 Floating point arc tangent.
</summary>
</member>
<member name="M:B2R2.BitVector.Extract(System.Int32,System.Int32)">
<summary>
 Extract a sub-BitVector of size (RegType) starting from the index (int).
</summary>
</member>
<member name="M:B2R2.BitVector.Eq(B2R2.BitVector)">
<summary>
 BitVector equal.
</summary>
</member>
<member name="M:B2R2.BitVector.Div(B2R2.BitVector)">
<summary>
 BitVector unsigned division.
</summary>
</member>
<member name="M:B2R2.BitVector.Div(System.UInt64)">
<summary>
 BitVector unsigned division with uint64.
</summary>
</member>
<member name="M:B2R2.BitVector.Concat(B2R2.BitVector)">
<summary>
 BitVector concatenation.
</summary>
</member>
<member name="M:B2R2.BitVector.Cast(System.Int32)">
<summary>
 Type-cast a BitVector to another type. If the target type is bigger than
 the current type, then this works the same as ZExt.
</summary>
</member>
<member name="M:B2R2.BitVector.BigValue">
<summary>
 Return the BigInteger representation of the bitvector value.
</summary>
</member>
<member name="M:B2R2.BitVector.ApproxEq(B2R2.BitVector)">
<summary>
 BitVector approximate equal. For high-precision floating point numbers,
 this function performs approximate equality check.
</summary>
</member>
<member name="M:B2R2.BitVector.And(B2R2.BitVector)">
<summary>
 BitVector bitwise AND.
</summary>
</member>
<member name="M:B2R2.BitVector.And(System.UInt64)">
<summary>
 BitVector bitwise AND with uint64.
</summary>
</member>
<member name="M:B2R2.BitVector.Add(B2R2.BitVector)">
<summary>
 BitVector addition.
</summary>
</member>
<member name="M:B2R2.BitVector.Add(System.UInt64)">
<summary>
 BitVector addition with uint64.
</summary>
</member>
<member name="M:B2R2.BitVector.Abs">
<summary>
 BitVector absolute value.
</summary>
</member>
<member name="T:B2R2.BitVector">
<summary>
 BitVector is the fundamental data type for binary code, which is essentially
 a bit vector. We want the size of a bit vector to be less than or equal to
 64 bits because bigint operation is slow, and most arithmetics on modern
 architectures are in 64 bits any ways. For example, SIMD operations can also
 be divided into a set of 64-bit operations.

 N.B. Num becomes zero when the Length becomes greater than 64. We
 intentionally do not sync Num and BigNum.
</summary>
</member>
<member name="F:B2R2.ProgramPoint.Position@">
<summary>
 Index of the IR statement within the instruction.
</summary>
</member>
<member name="F:B2R2.ProgramPoint.Address@">
<summary>
 Address of the instruction.
</summary>
</member>
<member name="P:B2R2.ProgramPoint.Position">
<summary>
 Index of the IR statement within the instruction.
</summary>
</member>
<member name="P:B2R2.ProgramPoint.Address">
<summary>
 Address of the instruction.
</summary>
</member>
<member name="M:B2R2.ProgramPoint.GetFake">
<summary>
 Get a fake program point to represent a fake vertex, which does not exist
 in a CFG. Fake vertices are useful for representing external function
 calls and their nodes in the SCFG.
</summary>
</member>
<member name="T:B2R2.ProgramPoint">
<summary>
 A program point (ProgramPoint) is a fine-grained location in a program,
 which can point to a specific IR statement. We represent it as a tuple:
 (Address of the instruction, Index of the IR stmt for the instruction).
</summary>
</member>
<member name="T:B2R2.BytePattern">
<summary>
 Represents a byte pattern.
</summary>
</member>
<member name="T:B2R2.ByteValue.OneByte">
<summary>
 This matches only one single byte value.
</summary>
</member>
<member name="T:B2R2.ByteValue.AnyByte">
<summary>
 This matches any byte, i.e., it is like a kleene star.
</summary>
</member>
<member name="M:B2R2.LEB128.DecodeUInt64(System.Byte[])">
<summary>
 Decode a LEB128-encoded integer into uint64. This function returns a tuple
 of (the decoded uint64, and the count of how many bytes were read).
</summary>
</member>
<member name="M:B2R2.LEB128.DecodeUInt64(System.ReadOnlySpan{System.Byte})">
<summary>
 Decode a LEB128-encoded integer into uint64. This function returns a tuple
 of (the decoded uint64, and the count of how many bytes were read).
</summary>
</member>
<member name="M:B2R2.LEB128.DecodeUInt32(System.Byte[])">
<summary>
 Decode a LEB128-encoded integer into uint32. This function returns a tuple
 of (the decoded uint32, and the count of how many bytes were read).
</summary>
</member>
<member name="M:B2R2.LEB128.DecodeUInt32(System.ReadOnlySpan{System.Byte})">
<summary>
 Decode a LEB128-encoded integer into uint32. This function returns a tuple
 of (the decoded uint32, and the count of how many bytes were read).
</summary>
</member>
<member name="M:B2R2.LEB128.DecodeSInt64(System.Byte[])">
<summary>
 Decode a LEB128-encoded integer into int64. This function returns a tuple
 of (the decoded int64, and the count of how many bytes were read).
</summary>
</member>
<member name="M:B2R2.LEB128.DecodeSInt64(System.ReadOnlySpan{System.Byte})">
<summary>
 Decode a LEB128-encoded integer into int64. This function returns a tuple
 of (the decoded int64, and the count of how many bytes were read).
</summary>
</member>
<member name="M:B2R2.LEB128.DecodeSInt32(System.Byte[])">
<summary>
 Decode a LEB128-encoded integer into int32. This function returns a tuple
 of (the decoded int32, and the count of how many bytes were read).
</summary>
</member>
<member name="M:B2R2.LEB128.DecodeSInt32(System.ReadOnlySpan{System.Byte})">
<summary>
 Decode a LEB128-encoded integer into int32. This function returns a tuple
 of (the decoded int32, and the count of how many bytes were read).
</summary>
</member>
<member name="T:B2R2.IntervalMap`1">
<summary>
 Interval-tree-based map, which maps an interval of type (AddrRange) to an
 IntervalMapElement (&apos;a).
</summary>
</member>
<member name="T:B2R2.IntervalMapElem`1">
<summary>
 An element for our interval map.
</summary>
</member>
<member name="T:B2R2.IntervalSet">
<summary>
 Interval tree-based set, which stores intervals (AddrRange) that can
 overlap unlike ARMap.
</summary>
</member>
<member name="T:B2R2.IntervalSetElem">
<summary>
 An element for our interval set.
</summary>
</member>
<member name="T:B2R2.RandomAccessQueue`1">
<summary>
 Interval tree-based map: an interval of type (Addr) -&gt; an
 RandomAccessQueueElement (&apos;a).
</summary>
</member>
<member name="T:B2R2.RandomAccessQueueElem`1">
<summary>
 An element for our random access queue.
</summary>
</member>
<member name="T:B2R2.LRUCache`2">
<summary>
 Least Recently Used Cache supporting concurrency. The capacity decides how
 many entries to store.
</summary>
</member>
<member name="T:B2R2.ICacheableOperation`2">
<summary>
 This is a cacheable operation, which will be executed when there&apos;s no
 already cached item.
</summary>
</member>
<member name="T:B2R2.EmptyBinReader">
<summary>
 Empty BinReader, representing a null type.
</summary>
</member>
<member name="T:B2R2.BinReaderBE">
<summary>
 This is a BinReader that reads values in a big-endian manner.
</summary>
</member>
<member name="T:B2R2.BinReaderLE">
<summary>
 This is a BinReader that reads values in a little-endian manner.
</summary>
</member>
<member name="P:B2R2.BinReader.Bytes(System.Byte[])">
<summary>
 The byte array stored for this reader.
</summary>
</member>
<member name="P:B2R2.BinReader.Endianness">
<summary>
 My endianness.
</summary>
</member>
<member name="P:B2R2.BinReader.Bytes">
<summary>
 The byte array stored for this reader.
</summary>
</member>
<member name="M:B2R2.BinReader.SubReader(System.Int32,System.Int32)">
<summary>
 Return a sub BinReader that serves a subset of the bytes starting at the
 offset (offset) and of the length (len).
</summary>
</member>
<member name="M:B2R2.BinReader.RenewReader(B2R2.BinReader,B2R2.Endian)">
<summary>
 Return a new BinReader of the given endianness. This function will return
 the same reader if the given endianness is the same as the endianness of
 the original reader.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadUInt8(System.Int32)">
<summary>
 Read a uint8 value at the given offset. This function, unlike PeekUInt8,
 will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadUInt64LEB128(System.Int32)">
<summary>
 Read a LEB128-encoded integer into uint64 at the given offset.
 This function, unlike PeekUInt64LEB128, will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadUInt64(System.Int32)">
<summary>
 Read a uint64 value at the given offset. This function, unlike PeekUInt64,
 will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadUInt32LEB128(System.Int32)">
<summary>
 Read a LEB128-encoded integer into uint32 at the given offset.
 This function, unlike PeekUInt32LEB128, will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadUInt32(System.Int32)">
<summary>
 Read a uint32 value at the given offset. This function, unlike PeekUInt32,
 will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadUInt16(System.Int32)">
<summary>
 Read a uint16 value at the given offset. This function, unlike PeekUInt16,
 will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadInt8(System.Int32)">
<summary>
 Read an int8 value at the given offset. This function, unlike PeekInt8,
 will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadInt64LEB128(System.Int32)">
<summary>
 Read a LEB128-encoded integer into int64 at the given offset.
 This function, unlike PeekInt64LEB128, will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadInt64(System.Int32)">
<summary>
 Read an int64 value at the given offset. This function, unlike PeekInt64,
 will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadInt32LEB128(System.Int32)">
<summary>
 Read a LEB128-encoded integer into int32 at the given offset.
 This function, unlike PeekInt32LEB128, will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadInt32(System.Int32)">
<summary>
 Read an int32 value at the given offset. This function, unlike PeekInt32,
 will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadInt16(System.Int32)">
<summary>
 Read an int16 value at the given offset. This function, unlike PeekInt16,
 will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadChars(System.Int32,System.Int32)">
<summary>
 Read a character array of size n at the given offset. This function,
 unlike PeekChars, will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadBytes(System.Int32,System.Int32)">
<summary>
 Read a byte array of size n at the given offset. This function, unlike
 PeekBytes, will return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.ReadByte(System.Int32)">
<summary>
 Read a byte at the given offset. This function, unlike PeekByte, will
 return the next offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekUInt8(System.Int32)">
<summary>
 Peek a single byte as a uint8 type at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekUInt64LEB128(System.Int32)">
<summary>
 Peek a LEB128-encoded integer at the given offset.
 This function returns a tuple of
 (the decoded uint64, and the count of how many bytes were peeked).
</summary>
</member>
<member name="M:B2R2.BinReader.PeekUInt64(System.Int32)">
<summary>
 Peek a uint64 value at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekUInt32LEB128(System.Int32)">
<summary>
 Peek a LEB128-encoded integer at the given offset.
 This function returns a tuple of
 (the decoded uint32, and the count of how many bytes were peeked).
</summary>
</member>
<member name="M:B2R2.BinReader.PeekUInt32(System.Int32)">
<summary>
 Peek a uint32 value at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekUInt16(System.Int32)">
<summary>
 Peek a uint16 value at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekSpan(System.Int32)">
<summary>
 Peek span of bytes at the given offset to the end.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekSpan(System.Int32,System.Int32)">
<summary>
 Peek span of bytes of size n at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekMem(System.Int32,System.Int32)">
<summary>
 Peek Memory of size n at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekInt8(System.Int32)">
<summary>
 Peek a single byte as an int8 type at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekInt64LEB128(System.Int32)">
<summary>
 Peek a LEB128-encoded integer at the given offset.
 This function returns a tuple of
 (the decoded int64, and the count of how many bytes were peeked).
</summary>
</member>
<member name="M:B2R2.BinReader.PeekInt64(System.Int32)">
<summary>
 Peek an int64 value at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekInt32LEB128(System.Int32)">
<summary>
 Peek a LEB128-encoded integer at the given offset.
 This function returns a tuple of
 (the decoded int32, and the count of how many bytes were peeked).
</summary>
</member>
<member name="M:B2R2.BinReader.PeekInt32(System.Int32)">
<summary>
 Peek an int32 value at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekInt16(System.Int32)">
<summary>
 Peek an int16 value at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekChars(System.Int32,System.Int32)">
<summary>
 Peek a character array of size n at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekBytes(System.Int32,System.Int32)">
<summary>
 Peek byte array of size n at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.PeekByte(System.Int32)">
<summary>
 Peek a single byte at the given offset.
</summary>
</member>
<member name="M:B2R2.BinReader.Length">
<summary>
 Length of the file for this reader.
</summary>
</member>
<member name="M:B2R2.BinReader.IsOutOfRange(System.Int32)">
<summary>
 Is the given offset points to a position out of the range of the file?
</summary>
</member>
<member name="M:B2R2.BinReader.Init(System.Byte[],B2R2.Endian)">
<summary>
 Instantiate BinReader from a given byte array and endianness.
</summary>
</member>
<member name="T:B2R2.BinReader">
<summary>
 BinReader abstracts away the process of reading byte sequences. This is the
 base class for BinReader, which has two kinds of implementations:
 little-endian and big-endian BinReader.
</summary>
</member>
<member name="T:B2R2.FileLogger">
<summary>
 Log to a file.
</summary>
</member>
<member name="M:B2R2.ILogger.LogLine(System.String,Microsoft.FSharp.Core.FSharpOption{B2R2.LogLevel})">
<summary>
 Log string with a new line.
</summary>
</member>
<member name="M:B2R2.ILogger.Log(System.String,Microsoft.FSharp.Core.FSharpOption{B2R2.LogLevel})">
<summary>
 Log string (without newline).
</summary>
</member>
<member name="T:B2R2.ILogger">
<summary>
 Basic logging facility.
</summary>
</member>
<member name="F:B2R2.LogLevel.L4">
<summary>
 Most verbose = level 4.
</summary>
</member>
<member name="F:B2R2.LogLevel.L3">
<summary>
 Verbose = level 3.
</summary>
</member>
<member name="F:B2R2.LogLevel.L2">
<summary>
 Normal = level 2.
</summary>
</member>
<member name="F:B2R2.LogLevel.L1">
<summary>
 Most succint = level 1.
</summary>
</member>
<member name="T:B2R2.LogLevel">
<summary>
 How verbose do we want to log messages?
</summary>
</member>
<member name="T:B2R2.InvalidRegTypeException">
<summary>
 This exception is raised when an invalid RegType is encountered.
</summary>
</member>
<member name="T:B2R2.RegisterSetTagMismatchException">
<summary>
 Raised when two RegisterSets with two distinct tags operate.
</summary>
</member>
<member name="T:B2R2.InvalidWordSizeException">
<summary>
 This exception is raised when an invalid WordSize is encountered.
</summary>
</member>
<member name="T:B2R2.InvalidEndianException">
<summary>
 Raised when an invalid Endian value is used.
</summary>
</member>
<member name="T:B2R2.UnknownOSException">
<summary>
 Raised when unknown OS type is detected.
</summary>
</member>
<member name="T:B2R2.InvalidTargetArchModeException">
<summary>
 Raised when an invalid ArchOperationMode is given.
</summary>
</member>
<member name="T:B2R2.InvalidISAException">
<summary>
 Raised when an invalid ISA is given as a parameter.
</summary>
</member>
<member name="T:B2R2.UnhandledSyscallException">
<summary>
 Raised when unhandled syscall is encountered.
</summary>
</member>
<member name="T:B2R2.InvalidAddrRangeException">
<summary>
 Raised when an AddrRange has the same Min and Max value, i.e., for invalid
 interval.
</summary>
</member>
<member name="T:B2R2.RangeOverlapException">
<summary>
 Raised when there is an overlapping intervals from the interval tree.
</summary>
</member>
<member name="T:B2R2.LEB128DecodeException">
<summary>
 Raised when LEB128 decoding failed, e.g., when the given input bytes has
 incorrect encoding.
</summary>
</member>
<member name="M:B2R2.Result.isOk``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 Is the result Ok?
</summary>
</member>
<member name="M:B2R2.Result.get``2(Microsoft.FSharp.Core.FSharpResult{``0,``1})">
<summary>
 Get the result assuming that there is no error.
</summary>
</member>
<member name="T:B2R2.Result">
<summary>
 Extended Result.
</summary>
</member>
<member name="M:B2R2.Option.getWithExn``1(Microsoft.FSharp.Core.FSharpOption{``0},System.Exception)">
<summary>
 Unwrap an option type. If the value is None, throw the exception (exn).
</summary>
</member>
<member name="T:B2R2.Option">
<summary>
 Extended Option.
</summary>
</member>
<member name="M:B2R2.Int64.pow(System.Int64,System.Int64)">
<summary>
 Get a power from a 64-bit integer.
</summary>
</member>
<member name="T:B2R2.Int64">
<summary>
 Extended Int64.
</summary>
</member>
<member name="M:B2R2.BigInteger.getMask(System.Int32)">
<summary>
 Get a bitmask of size n.
</summary>
</member>
<member name="P:B2R2.BigInteger.mask512">
<summary>
 Bitmask of size 512 bits.
</summary>
</member>
<member name="P:B2R2.BigInteger.mask256">
<summary>
 Bitmask of size 256 bits.
</summary>
</member>
<member name="P:B2R2.BigInteger.mask128">
<summary>
 Bitmask of size 128 bits.
</summary>
</member>
<member name="T:B2R2.BigInteger">
<summary>
 Extended BigInteger.
</summary>
</member>
<member name="M:B2R2.String.fromBytes(System.Byte[])">
<summary>
 Convert a byte array to a string.
</summary>
</member>
<member name="M:B2R2.String.toBytes(System.String)">
<summary>
 Convert a string to a byte array.
</summary>
</member>
<member name="T:B2R2.String">
<summary>
 Extended String.
</summary>
</member>
<member name="T:B2R2.Array">
<summary>
 Extended Array.
</summary>
</member>
<member name="T:B2R2.Monads.OrElse.OrElseBuilder">
<summary>
 A builder for OrElse computation expression.
</summary>
</member>
<member name="T:B2R2.Monads.OrElse">
<summary>
 OrElse represents computation expressions that capture the result until
 successful.
</summary>
</member>
<member name="T:B2R2.Monads.Maybe.MaybeBuilder">
<summary>
 A builder for Maybe computation expression.
</summary>
</member>
<member name="T:B2R2.Monads.Maybe">
<summary>
 Maybe represents computation expressions that might go wrong.
</summary>
</member>
<member name="M:B2R2.Utils.tripleThd``3(System.Tuple{``0,``1,``2})">
<summary>
 Return the third item of a triple.
</summary>
</member>
<member name="M:B2R2.Utils.tripleSnd``3(System.Tuple{``0,``1,``2})">
<summary>
 Return the second item of a triple.
</summary>
</member>
<member name="M:B2R2.Utils.tripleFst``3(System.Tuple{``0,``1,``2})">
<summary>
 Return the first item of a triple.
</summary>
</member>
<member name="M:B2R2.Utils.tupleToOpt``1(System.Boolean,``0)">
<summary>
 Convert a tuple result to an option type. The tuple result is obtained from
 the TryGetValue pattern, e.g., IDictionary.
</summary>
</member>
<member name="M:B2R2.Utils.op_EqualsEqualsEquals``1(``0,``0)">
<summary>
 Physical equality.
</summary>
</member>
<member name="M:B2R2.Utils.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
<summary>
 Uncurry a pair of arguments.
</summary>
</member>
<member name="M:B2R2.Utils.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``0,``1)">
<summary>
 Curry a pair of arguments.
</summary>
</member>
<member name="M:B2R2.Utils.tap``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0)">
<summary>
 Apply a procedure in the middle of function pipes.
</summary>
</member>
<member name="M:B2R2.Utils.impossible``1">
<summary>
 Fatal error. This should never happen.
</summary>
</member>
<member name="M:B2R2.Utils.futureFeature``1">
<summary>
 Not implemented features encountered, so raise an exception and die.
</summary>
</member>
<member name="M:B2R2.Utils.assertByCond(System.Boolean,System.Exception)">
<summary>
 Assert check condition. If not, raise an exception (exn).
</summary>
</member>
<member name="M:B2R2.Utils.assertEqual``1(``0,``0,System.Exception)">
<summary>
 Assert two values are equal. If not, raise an exception (exn).
</summary>
</member>
<member name="T:B2R2.Utils">
<summary>
 A set of convenient misc. functions.
</summary>
</member>
<member name="M:B2R2.ColoredStringModule.setColor(B2R2.Color)">
<summary>
 Set the color.
</summary>
</member>
<member name="M:B2R2.RegTypeModule.getMask(System.Int32)">
 <summary>
   Get a bitmask (in integer) from the given RegType.
 </summary>
 <returns>
   A bit mask in big integer.
 </returns>
</member>
<member name="M:B2R2.RegTypeModule.double(System.Int32)">
 <summary>
   Get a double-sized RegType from a given RegType.
 </summary>
 <param name="t">RegType.</param>
 <returns>
   A <see cref="T:B2R2.RegType"/>.
 </returns>
</member>
<member name="M:B2R2.RegTypeModule.fromByteWidth``1(System.Int32)">
 <summary>
   Get the corresponding integer RegType from the given byte width.
 </summary>
 <param name="n">Byte width in integer.</param>
 <returns>
   A <see cref="T:B2R2.RegType"/>.
 </returns>
</member>
<member name="M:B2R2.RegTypeModule.fromBitWidth``1(System.Int32)">
 <summary>
   Get the corresponding integer RegType from the given bit width. When a
   negative integer is given, it will return a floating point type.
 </summary>
 <param name="n">Bit width in integer.</param>
 <returns>
   A <see cref="T:B2R2.RegType"/>.
 </returns>
</member>
<member name="M:B2R2.RegTypeModule.toByteWidth(System.Int32)">
 <summary>
   Get a byte width from a RegType.
 </summary>
 <param name="t">RegType.</param>
 <returns>
   A byte width in integer of the given RegType.
 </returns>
</member>
<member name="M:B2R2.RegTypeModule.toBitWidth(System.Int32)">
 <summary>
   Convert a <see cref="T:B2R2.RegType"/> to an integer of bit width.
 </summary>
 <param name="t">RegType.</param>
 <returns>
   A bit width in integer of the given RegType.
 </returns>
</member>
<member name="M:B2R2.RegTypeModule.isFP(System.Int32)">
 <summary>
   Check if the given <see cref="T:B2R2.RegType"/> is a floating-point (FP)
   type.
 </summary>
 <param name="t">RegType.</param>
 <returns>
   A Boolean value that is true if the given RegType is a floating-point
   type, false otherwise.
 </returns>
</member>
<member name="M:B2R2.RegTypeModule.toString(System.Int32)">
 <summary>
   Convert <see cref="T:B2R2.RegType"/> to string.
 </summary>
 <param name="t">RegType.</param>
 <returns>
   A string representation for RegType. For example, I32 means a 32-bit
   integer type.
 </returns>
</member>
<member name="T:B2R2.RegTypeModule">
 <summary>
   A helper for <see cref="T:B2R2.RegType"/>.
 </summary>
</member>
<member name="T:B2R2.RegisterIDModule.T">
<summary>
 A unit for register IDs.
</summary>
</member>
<member name="M:B2R2.RegisterIDModule.create(System.Int32)">
<summary>
 Create a platform-independent register ID representation.
</summary>
</member>
<member name="T:B2R2.RegisterIDModule">
<summary>
 This class stores an identifier for a register. Each register in B2R2 has
 its own ID, which is essentially an integer value. However, one needs to go
 through this class to use a RegisterID.
</summary>
</member>
<member name="T:B2R2.RegisterSetModule">
<summary>
 A helper module for RegisterSet.
</summary>
</member>
<member name="M:B2R2.WordSizeModule.is256(B2R2.WordSize)">
<summary>
 Is the given word size 256 bit?
</summary>
</member>
<member name="M:B2R2.WordSizeModule.is128(B2R2.WordSize)">
<summary>
 Is the given word size 128 bit?
</summary>
</member>
<member name="M:B2R2.WordSizeModule.is64(B2R2.WordSize)">
<summary>
 Is the given word size 64 bit?
</summary>
</member>
<member name="M:B2R2.WordSizeModule.is32(B2R2.WordSize)">
<summary>
 Is the given word size 32 bit?
</summary>
</member>
<member name="M:B2R2.WordSizeModule.toString(B2R2.WordSize)">
<summary>
 Transform a word size into a string.
</summary>
</member>
<member name="M:B2R2.WordSizeModule.toRegType(B2R2.WordSize)">
<summary>
 Transform a word size into a RegType.
</summary>
</member>
<member name="M:B2R2.WordSizeModule.toByteWidth(B2R2.WordSize)">
<summary>
 Transform a word size into a byte length.
</summary>
</member>
<member name="T:B2R2.WordSizeModule">
<summary>
 A helper module for the WordSize type.
</summary>
</member>
<member name="M:B2R2.EndianModule.toString(B2R2.Endian)">
 <summary>
   Get the string representation from an Endian.
 </summary>
</member>
<member name="M:B2R2.EndianModule.ofString(System.String)">
 <summary>
   Get Endian from a string.
 </summary>
 <param name="str">The given string.</param>
 <returns>
   Endian.
 </returns>
</member>
<member name="T:B2R2.EndianModule">
<summary>
 A helper module for Endian type.
</summary>
</member>
<member name="M:B2R2.OSModule.isRunnable(System.String)">
<summary>
 Test if the given program name is runnable in the current environment
 by analyzing the PATH environment variable.
</summary>
</member>
<member name="T:B2R2.OSModule">
<summary>
 A helper module for OS type.
</summary>
</member>
<member name="T:B2R2.ArchOperationModeModule">
<summary>
 A helper module for ArchOperationMode.
</summary>
</member>
<member name="M:B2R2.FileFormatModule.isELF(B2R2.FileFormat)">
<summary>
 Check whether the given format is ELF.
</summary>
</member>
<member name="T:B2R2.FileFormatModule">
<summary>
 A helper module for FileFormat type.
</summary>
</member>
<member name="M:B2R2.ARMap.GetOverlaps``1(B2R2.AddrRange,B2R2.ARMap{``0})">
 <summary>
   Return a sequence of overlapping mappings of the given interval.
 </summary>
 <param name="range">The interval.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   A sequence of mappings.
 </returns>
</member>
<member name="M:B2R2.ARMap.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{B2R2.AddrRange,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,B2R2.ARMap{``1})">
 <summary>
   Fold over the tree.
 </summary>
 <param name="fn">Folder.</param>
 <param name="acc">Accumulator.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   Accumulated value.
 </returns>
</member>
<member name="M:B2R2.ARMap.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{B2R2.AddrRange,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},B2R2.ARMap{``0})">
 <summary>
   Iterate over the tree.
 </summary>
 <param name="fn">Iterator.</param>
 <param name="tree">The interval tree.</param>
</member>
<member name="M:B2R2.ARMap.Count``1(B2R2.ARMap{``0})">
 <summary>
   Return the number of bindings in the interval map.
 </summary>
 <param name="tree">The interval tree.</param>
 <returns>
   The number of bindings.
 </returns>
</member>
<member name="M:B2R2.ARMap.TryFindByAddr``1(System.UInt64,B2R2.ARMap{``0})">
 <summary>
   Same as findByAddr, except that this returns an option-wrapped type.
 </summary>
 <param name="addr">The address.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   The value associated with the given address.
 </returns>
</member>
<member name="M:B2R2.ARMap.TryFind``1(B2R2.AddrRange,B2R2.ARMap{``0})">
 <summary>
   Same as find, except that this returns an option-wrapped type.
 </summary>
 <param name="range">The address range.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   The value associated with the given interval.
 </returns>
</member>
<member name="M:B2R2.ARMap.TryFindKey``1(System.UInt64,B2R2.ARMap{``0})">
 <summary>
   Find an interval stored in the interval tree map, which includes the
   given address.
 </summary>
 <param name="addr">The address.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   The found interval wrapped with option.
 </returns>
</member>
<member name="M:B2R2.ARMap.FindByAddr``1(System.UInt64,B2R2.ARMap{``0})">
 <summary>
   Find the mapping that matches with the given range. Unlike find, this
   function can return a range that covers the given address.
 </summary>
 <param name="addr">The address.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   The value associated with the given address.
 </returns>
</member>
<member name="M:B2R2.ARMap.Find``1(B2R2.AddrRange,B2R2.ARMap{``0})">
 <summary>
   Find the mapping that exactly matches with the given range.
 </summary>
 <param name="range">The address range.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   The value associated with the given interval.
 </returns>
</member>
<member name="M:B2R2.ARMap.ContainsRange``1(B2R2.AddrRange,B2R2.ARMap{``0})">
 <summary>
   Check whether the exact range exists in the interval map.
 </summary>
 <param name="range">The address range.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   True if the interval tree contains the interval, false otherwise.
 </returns>
</member>
<member name="M:B2R2.ARMap.ContainsAddr``1(System.UInt64,B2R2.ARMap{``0})">
 <summary>
   Check whether a given Addr exists in any of the ranges in the map.
 </summary>
 <param name="addr">Address.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   True if the interval tree contains an interval that includes the given
   address, false otherwise.
 </returns>
</member>
<member name="M:B2R2.ARMap.RemoveAddr``1(System.UInt64,B2R2.ARMap{``0})">
 <summary>
   Remove a mapping that matches with the given address. Unlike remove,
   this function will remove an interval that includes the given address.
 </summary>
 <param name="addr">The address.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   A new interval tree.
 </returns>
</member>
<member name="M:B2R2.ARMap.Remove``1(B2R2.AddrRange,B2R2.ARMap{``0})">
 <summary>
   Remove a mapping that matches exactly with the given range. To remove a
   mapping that covers the given address, use removeAddr.
 </summary>
 <param name="k">The interval to find.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   A new interval tree.
 </returns>
</member>
<member name="M:B2R2.ARMap.Replace``1(B2R2.AddrRange,``0,B2R2.ARMap{``0})">
 <summary>
   This function is the same as add except that it will overwrite the
   existing range if it exactly matches with the given range. If ranges
   overlap, this function will still raise RangeOverlapException.
 </summary>
 <param name="k">AddrRange as a key.</param>
 <param name="v">The value to be added.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   A new interval tree.
 </returns>
</member>
<member name="M:B2R2.ARMap.AddRange``1(System.UInt64,System.UInt64,``0,B2R2.ARMap{``0})">
 <summary>
   This function is the same as add except that this one takes in two
   separate parameters for min and max, instead of taking in an AddrRange
   as input.
 </summary>
 <param name="min">The min value of the interval.</param>
 <param name="max">The max value of the interval.</param>
 <param name="v">The value to be added.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   A new interval tree.
 </returns>
 <exception cref="T:B2R2.RangeOverlapException">
   Thrown when there is an existing (overlapping) interval in the tree.
 </exception>
</member>
<member name="M:B2R2.ARMap.Add``1(B2R2.AddrRange,``0,B2R2.ARMap{``0})">
 <summary>
   Add a mapping from an interval to the value in the interval tree.
 </summary>
 <param name="k">AddrRange as a key.</param>
 <param name="v">The value to be added.</param>
 <param name="tree">The interval tree.</param>
 <returns>
   A new interval tree.
 </returns>
 <exception cref="T:B2R2.RangeOverlapException">
   Thrown when there is an existing (overlapping) interval in the tree.
 </exception>
</member>
<member name="M:B2R2.ARMap.IsEmpty``1(B2R2.ARMap{``0})">
 <summary>
   Check if the give interval map is empty.
 </summary>
 <param name="tree">The interval tree.</param>
 <returns>
   Returns true if the tree is empty, false otherwise.
 </returns>
</member>
<member name="M:B2R2.ARMap.Empty``1">
<summary>
 Return an empty map.
</summary>
</member>
<member name="T:B2R2.ARMap">
<summary>
 This is a helper class for manipulating an ARMap (AddressRangeMap), a
 non-overlapping interval map. We provide both F#- and C#-style APIs.
</summary>
</member>
<member name="T:B2R2.BitVectorHelper">
<summary>
 A helper module for BitVector.
</summary>
</member>
<member name="P:B2R2.BitVectorConstants.bigOne">
<summary>
 BigInteger one.
</summary>
</member>
<member name="P:B2R2.BitVectorConstants.bigZero">
<summary>
 BigInteger zero.
</summary>
</member>
<member name="M:B2R2.ByteArray.toUInt32Arr(System.Byte[])">
<summary>
 Convert a byte array into a uint32 array.
</summary>
</member>
<member name="M:B2R2.ByteArray.tryFindIdx(System.UInt64,System.Byte[],System.Byte[])">
<summary>
 Find a matching byte position. If there is no match, this function will
 return None.
</summary>
</member>
<member name="M:B2R2.ByteArray.findIdxs(System.UInt64,System.Byte[],System.Byte[])">
<summary>
 Find and return the offsets of all the matching byte positions. The final
 byte positions are adjusted by the given offset.
</summary>
</member>
<member name="M:B2R2.ByteArray.extractCStringFromSpan(System.ReadOnlySpan{System.Byte},System.Int32)">
<summary>
 Extract a C-string (string that ends with a NULL char) from a byte array.
</summary>
</member>
<member name="M:B2R2.ByteArray.extractCString(System.Byte[],System.Int32)">
<summary>
 Extract a C-string (string that ends with a NULL char) from a byte array.
</summary>
</member>
<member name="M:B2R2.ByteArray.readInt32(System.Byte[],System.Int32)">
<summary>
 Read int32 from the given byte array at the given offset.
</summary>
</member>
<member name="M:B2R2.ByteArray.toReadOnlySpan(System.Byte[])">
<summary>
 Convert a byte array into a read-only span.
</summary>
</member>
<member name="M:B2R2.ByteArray.ofHexString(System.String)">
<summary>
 Convert a hex string to a byte array.
</summary>
</member>
<member name="T:B2R2.ByteArray">
<summary>
 It is sometimes convenient to consider a binary chunk as a byte array. This
 module provides several useful functions to deal with byte arrays.
</summary>
</member>
<member name="M:B2R2.BytePatternModule.matchSpan(B2R2.ByteValue[],System.ReadOnlySpan{System.Byte})">
<summary>
 Check if the given span matches the pattern. The comparison starts at the
 offset zero.
</summary>
</member>
<member name="M:B2R2.BytePatternModule.match(B2R2.ByteValue[],System.Byte[])">
<summary>
 Check if the given byte array (bs) matches the pattern. The comparison
 starts at the very first byte of the arrays.
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.TakeUntil(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 Take a subset of a FingerTree that satisfies the predicate (p).
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.TailR(B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 Return tail of the right subtree.
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.TailL(B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 Return tail of the left subtree.
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.Split(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 Split a FingerTree into two based on a predicate (p).
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.Snoc(B2R2.FingerTree.FingerTree{`0,`1},`1)">
<summary>
 (infixl): Append an element to a FingerTree.
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.Lookup(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},`0,B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 TODO: (faster) lookup functions without building extra trees
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.HeadR(B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 Return head of the right subtree.
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.HeadL(B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 Return head of the left subtree.
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.DropUntil(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 Take a subset of a FingerTree that does not satisfies the predicate (p).
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.Cons(`1,B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 (infixr): Prepend an element to a FingerTree.
</summary>
</member>
<member name="M:B2R2.FingerTree.Op`2.Concat(B2R2.FingerTree.FingerTree{`0,`1},B2R2.FingerTree.FingerTree{`0,`1})">
<summary>
 Concatenate two FingerTrees into one.
</summary>
</member>
<member name="T:B2R2.FingerTree.Op`2">
<summary>
 This is a helper class that defines FingerTree operations. This class
 contains only static members. We use this class to simplify type annotations
 for polymorphic recursion.
</summary>
</member>
<member name="T:B2R2.FingerTree.Split`2">
<summary>
 Split represents an element in a FingerTree with containers of elements to
 its left and right.
</summary>
</member>
<member name="T:B2R2.FingerTree.View`2">
<summary>
 View of a FingerMap.
</summary>
</member>
<member name="T:B2R2.FingerTree.FingerTree`2">
<summary>
 FingerTree defined in [Hinze 2006]. N.B. non-regular type is used.
</summary>
</member>
<member name="T:B2R2.FingerTree.Digit`2">
<summary>
 Digit nodes actually store values.
</summary>
</member>
<member name="T:B2R2.FingerTree.Node`2">
<summary>
 2-3 tree node.
</summary>
</member>
<member name="T:B2R2.FingerTree.Size">
<summary>
 A size monoid for random access.
</summary>
</member>
<member name="T:B2R2.FingerTree.InterMonoid`1">
<summary>
 A monoid that represents an interval (uint64 * uint64).
</summary>
</member>
<member name="T:B2R2.FingerTree.Ordered`1">
<summary>
 A monoid that represents ordering.
</summary>
</member>
<member name="T:B2R2.FingerTree.Priority`1">
<summary>
 A monoid that represents a priority.
</summary>
</member>
<member name="T:B2R2.FingerTree.IMeasured`1">
<summary>
 A &quot;typeclass&quot; that has a measurement. The measurement should be a monoid.
</summary>
</member>
<member name="T:B2R2.FingerTree.IMonoid`1">
<summary>
 Monoid with an identity, and an associative operation.
</summary>
</member>
<member name="M:B2R2.FingerTree.foldl``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``2,B2R2.FingerTree.FingerTree{``0,``1})">
<summary>
 Reduce a FingerTree from the left.
</summary>
</member>
<member name="M:B2R2.FingerTree.foldr``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}},B2R2.FingerTree.FingerTree{``0,``1},``2)">
<summary>
 Reduce a FingerTree from the right.
</summary>
</member>
<member name="M:B2R2.FingerTree.calib``1(B2R2.FingerTree.IMeasured{``0})">
<summary>
 Returns the measurement.
</summary>
</member>
<member name="T:B2R2.FingerTree">
<summary>
 FingerTree implementation.
</summary>
</member>
<member name="M:B2R2.IntervalMap.iter``1(Microsoft.FSharp.Core.FSharpFunc{B2R2.AddrRange,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},B2R2.IntervalMap{``0})">
<summary>
 Iterate the map.
</summary>
</member>
<member name="M:B2R2.IntervalMap.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{B2R2.AddrRange,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0,B2R2.IntervalMap{``1})">
<summary>
 Fold the map.
</summary>
</member>
<member name="M:B2R2.IntervalMap.remove``1(B2R2.AddrRange,B2R2.IntervalMap{``0})">
<summary>
 Remove the exactly matched interval from the map.
</summary>
</member>
<member name="M:B2R2.IntervalMap.addOrReplace``1(B2R2.AddrRange,``0,B2R2.IntervalMap{``0})">
<summary>
 Add a new mapping to the IntervalMap when there is no exactly matching
 interval. If there is, replace the mapping with the new value.
</summary>
</member>
<member name="M:B2R2.IntervalMap.replace``1(B2R2.AddrRange,``0,B2R2.IntervalMap{``0})">
<summary>
 Replace the exactly matched interval from the map to the given one.
</summary>
</member>
<member name="M:B2R2.IntervalMap.contains``1(B2R2.AddrRange,B2R2.IntervalMap{``0})">
<summary>
 Check whether the exact range exists in the interval tree.
</summary>
</member>
<member name="M:B2R2.IntervalMap.containsAddr``1(System.UInt64,B2R2.IntervalMap{``0})">
<summary>
 Check whether the given address exists in the interval tree.
</summary>
</member>
<member name="M:B2R2.IntervalMap.includeRange``1(B2R2.AddrRange,B2R2.IntervalMap{``0})">
<summary>
 Check whether the given address interval is included in any of the
 intervals in the interval map.
</summary>
</member>
<member name="M:B2R2.IntervalMap.tryFindByMin``1(System.UInt64,B2R2.IntervalMap{``0})">
<summary>
 Find an interval that has the same low bound (Min) as the given address.
</summary>
</member>
<member name="M:B2R2.IntervalMap.tryFind``1(B2R2.AddrRange,B2R2.IntervalMap{``0})">
<summary>
 Find exactly matching interval.
</summary>
</member>
<member name="M:B2R2.IntervalMap.findAll``1(B2R2.AddrRange,B2R2.IntervalMap{``0})">
<summary>
 Find all overlapping intervals.
</summary>
</member>
<member name="M:B2R2.IntervalMap.addByTuple``1(System.UInt64,System.UInt64,``0,B2R2.IntervalMap{``0})">
<summary>
 Add an item to the interval tree.
</summary>
</member>
<member name="M:B2R2.IntervalMap.add``1(B2R2.AddrRange,``0,B2R2.IntervalMap{``0})">
<summary>
 Add an item to the interval tree.
</summary>
</member>
<member name="M:B2R2.IntervalMap.empty``1">
<summary>
 Empty interval tree.
</summary>
</member>
<member name="T:B2R2.IntervalMap">
<summary>
 Helper module for IntervalMap.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.iter(Microsoft.FSharp.Core.FSharpFunc{B2R2.AddrRange,Microsoft.FSharp.Core.Unit},B2R2.IntervalSet)">
<summary>
 Iterate the set.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.fold``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{B2R2.AddrRange,``0}},``0,B2R2.IntervalSet)">
<summary>
 Fold the set.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.contains(B2R2.AddrRange,B2R2.IntervalSet)">
<summary>
 Check whether the exact interval exists in the interval set.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.containsAddr(System.UInt64,B2R2.IntervalSet)">
<summary>
 Check whether the given address exists in the interval set.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.tryFindByAddr(System.UInt64,B2R2.IntervalSet)">
<summary>
 Find and return the first matching interval from the given address.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.tryFind(B2R2.AddrRange,B2R2.IntervalSet)">
<summary>
 Find and return the first matching interval from the given range.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.findAll(B2R2.AddrRange,B2R2.IntervalSet)">
<summary>
 Find all overlapping intervals.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.includeRange(B2R2.AddrRange,B2R2.IntervalSet)">
<summary>
 Check whether the given address interval is included in any of the
 intervals in the interval set.
</summary>
</member>
<member name="M:B2R2.IntervalSetModule.add(B2R2.AddrRange,B2R2.IntervalSet)">
<summary>
 Add an item to the interval tree.
</summary>
</member>
<member name="P:B2R2.IntervalSetModule.empty">
<summary>
 Empty interval tree.
</summary>
</member>
<member name="T:B2R2.IntervalSetModule">
<summary>
 Helper module for IntervalSet.
</summary>
</member>
<member name="M:B2R2.RandomAccessQueue.splitAt``1(System.UInt32,B2R2.RandomAccessQueue{``0})">
<summary>
 Split the queue based on the given index into two (left and right). The
 left queue will contain the entry at the given index.
</summary>
</member>
<member name="M:B2R2.RandomAccessQueue.empty``1">
<summary>
 Empty interval tree.
</summary>
</member>
<member name="T:B2R2.RandomAccessQueue">
<summary>
 A helper module for RandomAccessQueue&lt;&apos;a&gt;.
</summary>
</member>
<member name="P:B2R2.Attribution.copyright">
<summary>
 Copyright by SoftSec Lab. @ KAIST.
</summary>
</member>
<member name="T:B2R2.Attribution">
<summary>
 B2R2 project attribution.
</summary>
</member>
</members>
</doc>
